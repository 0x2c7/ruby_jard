{"name":"Ruby jard","tagline":"Just another ruby debugger. Provide a better experience while debugging Ruby","body":"# RubyJard\r\n\r\n![asciicast](./docs/logo.jpg)\r\n\r\nJard stands for Just Another Ruby Debugger, aims to c. Ruby Jard supports the following major features at the moment: \r\n\r\n- Informative Terminal UI, reduce your mental effort for repeated stuff so that you can focus on killing bugs.\r\n- Highlighted source code screen.  \r\n- Backtrace visualization and navigation. \r\n- Auto variable display in the current context. \r\n- Multi-thread exploration and debugging.\r\n\r\nRuby Jard's core is [Byebug](https://github.com/deivid-rodriguez/byebug), an awesome de factor debugger for Ruby. Therefore, Ruby Jard supports most of Byebug's functionalities.\r\n\r\nIf you still don't know what it is, let's watch this video. \r\n\r\n[![asciicast](https://asciinema.org/a/348526.svg)](https://asciinema.org/a/348526)\r\n\r\n## Getting Started\r\n\r\n**Warning**: Ruby Jard is still under heavy development. Bugs and weird behaviors are expected. If you see one, please don't hesitate to open an issue. I'll try my best to fix.\r\n\r\nAdd `ruby_jard` to your Gemfile, recommend to put it in test or development environment.\r\n\r\n``` ruby\r\ngem 'ruby_jard'\r\n```\r\n\r\nAdd magic method `jard` before the line you want to debug, just like `byebug`\r\n\r\n```ruby\r\ndef test_method\r\n  a = 1\r\n  b = 2\r\n  jard # Debugger will stop here\r\n  c = a + b\r\nend\r\n```\r\n\r\n## Screens\r\n\r\nWhen Jard attaches at any line of code, the main tile-style UI shows up. By default, there are 5 areas on the UI that you'll be interested.\r\n\r\n### Source panel\r\n\r\n<img src=\"./docs/screen-source.png\" alt=\"Source screen\" style=\"max-width: 500px;\" />\r\n\r\nThis panel shows the current line of code that your program is stopping, and surrounding related lines. The number of lines shown in this panel depends on your current terminal height, but never less than 5. \r\n\r\nRuby Jard supports any file extensions that your program runs into, especially `.rb`, `.erb`, `.haml` files. Other file types may encounter minor syntax highlighting issues.\r\n\r\nRuby Jard also supports inspecting gems and libraries, if you are interested.\r\n\r\n### Backtrace panel\r\n\r\n<img src=\"./docs/screen-backtrace.png\" alt=\"Screen backtrace\" style=\"max-width: 500px;\" />\r\n\r\nThis panel describes the current backtrace of the current thread your program is stopping. Each line of this panel describes the current Frame. What is frame and backtrace by the way? Let's step back a little bit at how Ruby executes your code. Internally, Ruby uses an interpreter to read and execute your code, line by line (technically, YARD instructions, but let's go with a simple version). When it meets a chunk of code that needs to open a new scope, like method calls or inline-block call, the interpreter creates a new structure to store the current context so that it can link to the next scope and go back later. This data structure is call Frame. The interpreter pushes frame into a stack, called backtrace (or stack trace, or call stack, whatever), and continues to execute your code. Each thread has a separate backtrace. To understand deeply, you may be interested in this wonderful slide: [Grow and Shrink - Dynamically Extending the Ruby VM Stack](https://www.slideshare.net/KeitaSugiyama1/grow-and-shrink-dynamically-extending-the-ruby-vm-stack). \r\n\r\nOverall, the whole backtrace panel lets you know where you are stopping at, the trace of how your program is running. When combining with other tools and other panels, you will be surprised by how much information the bugger can help you when you encounter your bugs.\r\n\r\nEach frame includes the following information:\r\n\r\n- Frame ID: incremental, can be used to jump to an arbitrary frame with frame command.\r\n- Current location label: a class name and method name of the method covers its frame. If there is a `[c]` prefix in front of a class name, it means that the method is provided by Ruby, implemented in C, and impossible to peek.\r\n- Current physical location: exact file name and line number. If a frame is allocated in a gem, the physical location shows a gem name and version only. For example: `RSpec::Core::Hooks::HookCollections in run in rspec-core (3.9.2)`.\r\n\r\n### Variable panel\r\n\r\n<img src=\"./docs/screen-variables.png\" alt=\"Variables screen\" style=\"max-width: 500px;\" />\r\n\r\nThe variable panel lets you explore all the local variables, instance variables, and constants in the current display context. Each variable is described by:\r\n\r\n- Inline indicator: the beginning dot (`â€¢`) implies a variable that appears in the current line. \r\n- Variable type: allow you to know the type of a variable at a single glance. Only built-in types, such as `int`, `flt`, `hash`, `bool`, `rng`, are supported. Instances of any classes will be noted as `var`.\r\n- Size of variable: the size of collection-like variables. Current Jard version supports 3 types:\r\n  - Hash: this field shows the number of keys \r\n  - Array: this field shows the number of items\r\n  - String: this field shows the number of character (fetched from`String#size` method)\r\n- Variable inspection: the content of the variable. The current Jard version generates this field by calling `#inspect`. **Known issue**: this accidentally triggers materializing method of objects, such as `ActiveRecord::Relation`. Future Jard version gonna fix this by a new safe generator.\r\n\r\nThis panel interacts well with backtrace panel and backtrace-exploring commands such as (`up`, `down`, `frame`, etc.) to inspect relative variables at each frame layer in the program. A common use case is to recall the parameter values you forgot when digging too deep into a method call. \r\n\r\nBy default, the variables are sorted by the following criteria:\r\n\r\n- Pinned variables (coming soon)\r\n- Current context (self)\r\n- Local variables\r\n- Instance variables\r\n- Constants\r\n- Global variables (coming soon)\r\n\r\n### Thread panel\r\n\r\n<img src=\"./docs/screen-threads.png\" alt=\"Screen threads\" style=\"max-width: 500px;\" />\r\n\r\nShow all the threads running at the moment. This panel is useful when you are working with a complicated multi-threaded environment like web server, or background jobs. \r\n\r\n### Repl panel\r\n\r\n<img src=\"./docs/screen-repl.png\" alt=\"Screen repl\" />\r\n\r\nAn interactive Repl for you to interact with your program, inspect values, update values, or control the debug flow as you want. The heart of Jard's repl is [Pry](https://github.com/pry/pry), a masterpiece gem. When you type a command, Jard parses, and does corresponding actions if what you type matches supported command. Otherwise, they are evaluated as Ruby code.\r\n\r\n## Commands\r\n\r\n### Step\r\n\r\n**Repl command**: `step`\r\n\r\n**Key binding**: F7\r\n\r\nDetect and step into a method call or block in the current line. If there isn't anything to step in, the program continues to next line. In case there are multiple methods on the same line, Jard hornors Ruby's execution order.\r\n\r\n### Step out\r\n\r\n**Repl command**: `step-out`\r\n\r\n**Key binding**: Shift + F7\r\n\r\nThe opposite of step out. This command is used to finish the execution of current frame, and jump to the next line of upper frame. In other words, this command is equivalent to the sequence `up` and `next`. If the neighbor frame already finishes, it continues with even higher frame.\r\n\r\nThis command is useful when you loose your interest in frame, and want to quickly go up again. One example is that you accidentally step into a longgggg loop with nothing useful. Another example is that you step into the library source code and don't really care what it does underlying.\r\n\r\n### Next\r\n\r\n**Repl command**: `next`\r\n\r\n**Key binding**: F8\r\n\r\nContinue to the next line in the current frame, by pass any steppable method call or blocks in the mid way unless they contains dynamic breakpoint or any `jard` attachment command. If the current frame already reaches the end, it continues to the next line of upper frame and so on. \r\n\r\n### Continue\r\n\r\n**Repl command**: `continue`\r\n\r\n**Key binding**: F9\r\n\r\nContinue the execution of your program to the end, or stop at the first dynamic break point or `jard` attachment command. One common confusion is that long-running ruby processes, such as web server or background jobs, won't stop, and may be used to debug the next request without restarting. If you want to end everything and just exit the process, let's use `exit`.\r\n\r\n### Up\r\n\r\n**Repl command**: `up`\r\n\r\n**Key binding**: F6\r\n\r\nExplore the upper frame. When you use this command, all associated displaying screens will be updated accordingly, but your program current position is still at the latest frame. This command is mostly used to explore, and view the trace, input parameters, or how your program stops at the current position. When use this command, you should have a glance at Variable panel, and Source panel to see the variables at destination frame. \r\n\r\nYou can combine with `next` or `step` to perform powerful execution redirection at the destination frame. Let's look at an example. You are debugging a chain of 10 rack middlewares, you go deep into the #9 middleware, found something, then want to go back to #5 middleware. It's pretty boring and frustrated to just use `next` or `step-out` and hope it eventually goes back. Now use `up` for some times (or `frame`, described below) to go to your desired frame, and use `next` there. Tada, it's magical, just like teleport.\r\n\r\nOne note is that you cannot explore a frame in c.\r\n\r\n### Down\r\n\r\n**Repl command**: `down`\r\n\r\n**Key binding**: Shift+F6\r\n\r\nExplore the lower frame. See `up` command for more information.\r\n\r\n### Frame\r\n\r\n**Repl command**: `frame <frame_id>`\r\n\r\n**Key binding:** None\r\n\r\n**Examples**:`frame 10`\r\n\r\nExplore a particular frame with id `<frame_id>`. It's faster than `up` and `down`. See `up` command for more information. \r\n\r\n\r\n\r\n## Roadmap\r\n\r\nThe ultimate goal of Ruby Jard is to provide a better experience while debugging Ruby. All the items in the roadmap are supposed to serve that. However, I have a life. There won't be any promises on when those items will be finished. In fact, this roadmap may be changed at anytime, depends on the current direction, focus and circumstances. \r\n\r\n### [Done] Version 0.1.0: Proof of concept\r\n\r\nThis version is a bootstrap to see whether my idea works or not, in term of technical possibility and user usability. Luckily, everything works now, and I receive possible feedback from friends and peers.\r\n\r\n### [Done] Version 0.2.0: UI completeness\r\n\r\nThe bootstrap version is just a series of ugly prints on stdout. It's frustrated as many things can be broken, wrong drawing, text overlapping, etc. This version is to fix those issues, and provide a foundation for more complicated drawing.\r\n\r\n### Version 0.3.0: Complete the workflow\r\n\r\nThis version focuses on making Jard usable for daily activities of any developer. In other words, this version is to become a complete replacement for Byebug (sorry :pray:). \r\n\r\n- Dynamic breakpoints.\r\n- Watch expressions.\r\n- Pin variables.\r\n- Program's STDOUT panel.\r\n- Post moterm.\r\n- Trace variable changes.\r\n- Multi-threaded debugging.\r\n- Fulfill options for existing commands.\r\n- Add more commands to control workflow.\r\n- etc.\r\n\r\n### Version 0.4.0: User satisfaction\r\n\r\nRuby Jard now serves well for all debugging use case. But it becomes floated, hard to use, and maybe just not \"click\" for the user. This version focuses on improve userability, stability, bugs, tweak small details. So that, after this version, Ruby Jard is just pleasant to use.\r\n\r\n- Support different screen sizes.\r\n- Minimal layout configuration.\r\n- Allow customizations (keyboard shortcut for example).\r\n- Rebuild variable inspection to optimize for each data type, especially nested complicated structure.\r\n- Collapsible and expandale variable inspection.\r\n- Windows, viewport, scrolling, etc.\r\n- Navigate between panels.\r\n- Build a buffer system to reduce interaction with STDOUT, and eventually improve drawing latency.\r\n\r\n### Version 0.5.0: Integration\r\n\r\nAccept or not, not everyone uses vim, or even terminal. Even in the terminal, I just want to provide minimal layout customizations, as I don't want to rebuild Tmux. Therefore, integration with other powerful systems to extend use cases, adapt different work flow and preferences is the focus on this version. I'm not sure about the ultimate solution, but at my limited knowledge now, [Debugger Adapter Protocol](https://microsoft.github.io/debug-adapter-protocol/) looks promising.\r\n\r\n- Prepare the infrastructure for DAP protocol.\r\n- Separate and split the panels into possible isolated processes, connect them together with DAP.\r\n- Fully layout configurations and integrate with Tmux.\r\n- Integrate with Vim 8+/Neovim via Terminal mode.\r\n- Integrate with Visual Studio Code via DAP.\r\n- Integrate with Emacs via dap mode.\r\n- Encrypted remote debugging.\r\n\r\n### Further future\r\n\r\nI won't stop until 0.5.0 version, even Jard doesn't have any users. However, as soon as it reaches 0.5.0, and serves my interest well, I don't have much things in mind now. The future is uncertain. Dreaming is good. Making dreams come true is hard, and time-consuming. Hope I can reach that future.\r\n\r\n## Contributing\r\n\r\nBug reports and pull requests are welcome on GitHub at https://github.com/nguyenquangminh0711/ruby_jard. This project is intended to be a safe, welcoming space for collaboration, and contributors are expected to adhere to the [code of conduct](https://github.com/nguyenquangminh0711/ruby_jard/blob/master/CODE_OF_CONDUCT.md).\r\n\r\n\r\n## License\r\n\r\nThe gem is available as open source under the terms of the [MIT License](https://opensource.org/licenses/MIT).\r\n\r\n## Code of Conduct\r\n\r\nEveryone interacting in the RubyJard project's codebases, issue trackers, chat rooms and mailing lists is expected to follow the [code of conduct](https://github.com/[USERNAME]/ruby_jard/blob/master/CODE_OF_CONDUCT.md).\r\n","note":"Don't delete this file! It's used internally to help with page regeneration."}